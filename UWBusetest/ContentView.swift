//
//  UWBusetestApp.swift
//  UWBusetest
//
//  Created by Â∞èÊ≠¶Âè≥‰∫¨ on 2024/10/10.
//

import SwiftUI
import NearbyInteraction
import MultipeerConnectivity
import UIKit // for opening Settings

@main
struct UWBusetestApp: App {
    var body: some Scene {
        WindowGroup {
            ContentView()
        }
    }
}

// MARK: - LogEntry
struct LogEntry: Identifiable, Equatable {
    let id: UUID
    let date: Date
    let message: String

    init(message: String, date: Date = Date()) {
        self.id = UUID()
        self.date = date
        self.message = message
    }

    var formatted: String {
        let t = DateFormatter.localizedString(from: date, dateStyle: .none, timeStyle: .medium)
        return "\(t) - \(message)"
    }
}

struct UWBPlotView: View {
    var positions: [CGPoint] // Áõ∏Êâã„ÅÆÂ∫ßÊ®ôÂ±•Ê≠¥„ÇíÊ∏°„Åô
    
    var body: some View {
        GeometryReader { geo in
            ZStack {
                // ËÉåÊôØÔºàÂ∫ßÊ®ôËª∏Ôºâ
                Rectangle()
                    .fill(Color(.systemBackground))
                Path { path in
                    let midX = geo.size.width / 2
                    let midY = geo.size.height / 2
                    path.move(to: CGPoint(x: midX, y: 0))
                    path.addLine(to: CGPoint(x: midX, y: geo.size.height))
                    path.move(to: CGPoint(x: 0, y: midY))
                    path.addLine(to: CGPoint(x: geo.size.width, y: midY))
                }
                .stroke(Color.gray.opacity(0.5), lineWidth: 1)

                // Áõ∏Êâã„ÅÆ‰ΩçÁΩÆÂ±•Ê≠¥
                ForEach(positions.indices, id: \.self) { i in
                    let p = positions[i]
                    Circle()
                        .fill(i == positions.count - 1 ? Color.red : Color.blue)
                        .frame(width: 8, height: 8)
                        .position(
                            x: geo.size.width/2 + p.x * 50, // „Çπ„Ç±„Éº„É´Ë™øÊï¥
                            y: geo.size.height/2 - p.y * 50
                        )
                }
            }
        }
    }
}



// MARK: - ContentView (ÂÖ®‰Ωì)
struct ContentView: View {
    @StateObject private var nearbyManager = NearbyInteractionManager()
    @StateObject private var peerSession = MCPeerIDSession()

    @State private var showPermissionAlert = false

    // „É°„ÉÉ„Çª„Éº„Ç∏ÈÄÅÂèó‰ø°Áî®
    @State private var message: String = ""
    @State private var receivedMessages: [String] = []

    //‰ΩçÁΩÆÊÉÖÂ†±„Éó„É≠„ÉÉ„ÉàÁî®
    @State private var positions: [CGPoint] = []


    var body: some View {
        VStack(spacing: 12) {
            Text("Nearby Interaction Demo")
                .font(.title2)
                .bold()

            // Ë∑ùÈõ¢Ë°®Á§∫
            Group {
                if let d = nearbyManager.lastDistance {
                    Text(String(format: "Ë∑ùÈõ¢: %.2f m", d))
                        .font(.headline)
                } else {
                    Text("Ë∑ùÈõ¢: Êú™ÂèñÂæó")
                        .font(.headline)
                }
            }

            // ÊñπÂêëË°®Á§∫
            Group {
                if let dir = nearbyManager.lastDirection {
                    Text(String(format: "ÊñπÂêë: x %.2f  y %.2f  z %.2f", dir.x, dir.y, dir.z))
                        .font(.subheadline)
                } else {
                    Text("ÊñπÂêë: Êú™ÂèñÂæó")
                        .font(.subheadline)
                }
            }

            HStack(spacing: 12) {
                Button("„Çª„ÉÉ„Ç∑„Éß„É≥Ê∫ñÂÇô") {
                    nearbyManager.prepareMySession()
                }
                .padding(8)
                .background(Color(.systemGray5))
                .cornerRadius(8)

                Button("„Éà„Éº„ÇØ„É≥ÈÄÅ‰ø°ÔºàÊâãÂãïÔºâ") {
                    if let data = nearbyManager.myTokenData {
                        peerSession.sendToken(data)
                    } else {
                        peerSession.log("Ëá™ÂàÜ„ÅÆ token „ÅåÊú™‰ΩúÊàê„Åß„Åô„ÄÇÂÖà„Å´„Çª„ÉÉ„Ç∑„Éß„É≥Ê∫ñÂÇô„Çí„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ")
                    }
                }
                .disabled(!peerSession.isConnected || nearbyManager.myTokenData == nil)
                .padding(8)
                .background((!peerSession.isConnected || nearbyManager.myTokenData == nil) ? Color(.systemGray4) : Color(.systemGray5))
                .cornerRadius(8)
            }

            Divider().padding(.vertical, 6)

            // „É°„ÉÉ„Çª„Éº„Ç∏ÈÄÅ‰ø°Ê¨Ñ
            HStack {
                TextField("„É°„ÉÉ„Çª„Éº„Ç∏„ÇíÂÖ•Âäõ", text: $message)
                    .textFieldStyle(RoundedBorderTextFieldStyle())
                Button("ÈÄÅ‰ø°") {
                    peerSession.sendMessage(message)
                    message = ""
                }
            }
            .padding(.vertical, 6)

            // Âèó‰ø°„É°„ÉÉ„Çª„Éº„Ç∏Ë°®Á§∫
            VStack(alignment: .leading, spacing: 4) {
                ForEach(receivedMessages, id: \.self) { msg in
                    Text("üì© \(msg)")
                        .font(.footnote)
                        .padding(4)
                        .background(Color(.secondarySystemBackground))
                        .cornerRadius(6)
                }
            }
            .frame(maxHeight: 150)

            Divider().padding(.vertical, 6)

            UWBPlotView(positions: positions)
                .frame(height: 300)
                .padding()

            // „É≠„Ç∞Ë°®Á§∫Ôºà„Çπ„ÇØ„É≠„Éº„É´Ôºâ
            Text("„É≠„Ç∞")
                .font(.headline)
                .frame(maxWidth: .infinity, alignment: .leading)

            ScrollView {
                VStack(alignment: .leading, spacing: 6) {
                    ForEach(mergedLogs(), id: \.id) { entry in
                        Text(entry.formatted)
                            .font(.caption2)
                            .frame(maxWidth: .infinity, alignment: .leading)
                            .padding(6)
                            .background(Color(.secondarySystemBackground))
                            .cornerRadius(6)
                    }
                }
                .padding(.bottom, 8)
            }
            .frame(maxHeight: 300)

            Spacer()
        }
        .padding()
        .onAppear {
            nearbyManager.prepareMySession()
            peerSession.log("onAppear: prepareMySession() Âëº„Å≥Âá∫„ÅóÊ∏à„Åø")

            // „É°„ÉÉ„Çª„Éº„Ç∏Âèó‰ø°„Éè„É≥„Éâ„É©Ë®≠ÂÆö
            peerSession.onPeerMessage = { text in
                receivedMessages.append(text)
            }
        }
        .onChange(of: peerSession.receivedTokenData) { newData in
            guard let data = newData else { return }
            nearbyManager.log("ContentView observed receivedTokenData (\(data.count) bytes)")
            nearbyManager.runMySession(peerTokenData: data)
            sendMyTokenWithRetryIfNeeded(retryCount: 6, delay: 0.5)
        }
        .onChange(of: nearbyManager.permissionDeniedFlag) { v in
            if v { showPermissionAlert = true }
        }
        //„Éó„É≠„ÉÉ„Éà„Ç∞„É©„Éï
        .onChange(of: nearbyManager.lastDirection) { newDir in
            if let dir = newDir, let dist = nearbyManager.lastDistance {
                let x = CGFloat(dir.x) * CGFloat(dist)
                let y = CGFloat(dir.y) * CGFloat(dist)
                positions.append(CGPoint(x: x, y: y))
            }
        }

        .alert("Nearby Interaction „ÅÆË®±ÂèØ„ÅåÂøÖË¶Å„Åß„Åô", isPresented: $showPermissionAlert) {
            Button("Ë®≠ÂÆö„ÇíÈñã„Åè") {
                if let url = URL(string: UIApplication.openSettingsURLString) {
                    UIApplication.shared.open(url, options: [:], completionHandler: nil)
                }
            }
            Button("Èñâ„Åò„Çã", role: .cancel) {}
        } message: {
            Text("Ë®≠ÂÆö ‚Üí „Éó„É©„Ç§„Éê„Ç∑„Éº ‚Üí „É≠„Éº„Ç´„É´„Éç„ÉÉ„Éà„ÉØ„Éº„ÇØ „Åß„Åì„ÅÆ„Ç¢„Éó„É™„ÅÆ„Ç¢„ÇØ„Çª„Çπ„ÇíË®±ÂèØ„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ")
        }
    }

    private func sendMyTokenWithRetryIfNeeded(retryCount: Int, delay: TimeInterval) {
        guard retryCount > 0 else {
            peerSession.log("sendMyTokenWithRetryIfNeeded: Ëá™ÂàÜ„ÅÆ token Ëøî‰ø°„Å´Â§±ÊïóÔºàtimeoutÔºâ")
            return
        }
        if let myToken = nearbyManager.myTokenData {
            peerSession.log("sendMyTokenWithRetryIfNeeded: Ëá™ÂàÜ„ÅÆ token „ÇíËøî‰ø°„Åó„Åæ„Åô (\(myToken.count) bytes)")
            peerSession.sendToken(myToken)
        } else {
            DispatchQueue.main.asyncAfter(deadline: .now() + delay) {
                self.sendMyTokenWithRetryIfNeeded(retryCount: retryCount - 1, delay: delay)
            }
        }
    }

    private func mergedLogs() -> [LogEntry] {
        let all = nearbyManager.logs + peerSession.logs
        return all.sorted { $0.date < $1.date }
    }
}

// MARK: - NearbyInteractionManager
class NearbyInteractionManager: NSObject, ObservableObject, NISessionDelegate {
    @Published var niSession: NISession? = nil
    @Published var myTokenData: Data? = nil
    @Published var lastDistance: Double? = nil
    @Published var lastDirection: SIMD3<Float>? = nil
    @Published var logs: [LogEntry] = []
    @Published var permissionDeniedFlag: Bool = false

    func log(_ s: String) {
        let entry = LogEntry(message: "[NI] \(s)")
        DispatchQueue.main.async {
            self.logs.append(entry)
            if self.logs.count > 500 { self.logs.removeFirst(self.logs.count - 500) }
        }
        print(entry.formatted)
    }

    func prepareMySession() {
        guard NISession.isSupported else {
            log("NISession „ÅØ„Åì„ÅÆ„Éá„Éê„Ç§„Çπ„Åß„Çµ„Éù„Éº„Éà„Åï„Çå„Å¶„ÅÑ„Åæ„Åõ„Çì„ÄÇ")
            return
        }
        if niSession != nil {
            niSession?.invalidate()
            niSession = nil
        }
        niSession = NISession()
        niSession?.delegate = self
        if let discoveryToken = niSession?.discoveryToken {
            do {
                let data = try NSKeyedArchiver.archivedData(withRootObject: discoveryToken, requiringSecureCoding: true)
                DispatchQueue.main.async { self.myTokenData = data }
                log("myTokenData „Çí‰ΩúÊàê„Åó„Åæ„Åó„ÅüÔºà\(data.count) bytesÔºâ")
            } catch {
                log("„Éà„Éº„ÇØ„É≥„ÅÆ„Ç¢„Éº„Ç´„Ç§„Éñ„Å´Â§±Êïó: \(error)")
            }
        } else {
            log("discoveryToken „ÅåÂèñÂæó„Åß„Åç„Åæ„Åõ„Çì„Åß„Åó„Åü„ÄÇ")
        }
    }

    func runMySession(peerTokenData: Data) {
        if niSession == nil {
            niSession = NISession()
            niSession?.delegate = self
            log("runMySession: niSession „ÅåÊú™‰ΩúÊàê„Å†„Å£„Åü„Åü„ÇÅÊñ∞Ë¶è‰ΩúÊàê„Åó„Åæ„Åó„Åü„ÄÇ")
        }
        do {
            let peerToken = try NSKeyedUnarchiver.unarchivedObject(ofClass: NIDiscoveryToken.self, from: peerTokenData)
            guard let token = peerToken else {
                log("peerToken „ÅÆ„Éá„Ç≥„Éº„ÉâÁµêÊûú„Åå nil „Åß„Åó„Åü„ÄÇ")
                return
            }
            let config = NINearbyPeerConfiguration(peerToken: token)
            niSession?.run(config)
            log("NINearbyPeerConfiguration „Çí run „Åó„Åæ„Åó„Åü„ÄÇ")
        } catch {
            log("peerToken „ÅÆ„Éá„Ç≥„Éº„Éâ„Å´Â§±Êïó„Åó„Åæ„Åó„Åü: \(error)")
        }
    }

    func session(_ session: NISession, didInvalidateWith error: Error) {
        let nsErr = error as NSError
        log("NISession invalidated. localizedDescription: \(error.localizedDescription)")
        if nsErr.domain == "com.apple.NearbyInteraction" && nsErr.code == -5884 {
            DispatchQueue.main.async { self.permissionDeniedFlag = true }
            log("Nearby Interaction „ÅÆË®±ÂèØ„ÅåÊãíÂê¶„Åï„Çå„Å¶„ÅÑ„Åæ„Åô")
        }
        DispatchQueue.main.async {
            self.lastDistance = nil
            self.lastDirection = nil
        }
        DispatchQueue.main.asyncAfter(deadline: .now() + 1.0) { [weak self] in
            self?.prepareMySession()
        }
    }

    func session(_ session: NISession, didUpdate nearbyObjects: [NINearbyObject]) {
        guard let obj = nearbyObjects.first else {
            log("nearbyObjects „ÅåÁ©∫„Åß„Åô„ÄÇ")
            DispatchQueue.main.async {
                self.lastDistance = nil
                self.lastDirection = nil
            }
            return
        }
        if let floatDistance = obj.distance {
            let d = Double(floatDistance)
            DispatchQueue.main.async { self.lastDistance = d }
            log(String(format: "Ë∑ùÈõ¢Êõ¥Êñ∞: %.3f m", d))
        } else {
            DispatchQueue.main.async { self.lastDistance = nil }
            log("Ë∑ùÈõ¢ÊÉÖÂ†±„Åå„ÅÇ„Çä„Åæ„Åõ„Çì„ÄÇ")
        }
        if let dir = obj.direction {
            DispatchQueue.main.async { self.lastDirection = dir }
            log(String(format: "ÊñπÂêëÊõ¥Êñ∞: x:%.3f y:%.3f z:%.3f", dir.x, dir.y, dir.z))
        } else {
            DispatchQueue.main.async { self.lastDirection = nil }
            log("ÊñπÂêëÊÉÖÂ†±„Åå„ÅÇ„Çä„Åæ„Åõ„Çì„ÄÇ")
        }
    }
}

// MARK: - MCPeerIDSession
class MCPeerIDSession: NSObject, ObservableObject {
    private let peerID: MCPeerID
    private let serviceType = "ni-demo"
    private var session: MCSession
    private var advertiser: MCNearbyServiceAdvertiser
    private var browser: MCNearbyServiceBrowser

    @Published var receivedTokenData: Data? = nil
    @Published var isConnected: Bool = false
    @Published var logs: [LogEntry] = []

    // „É°„ÉÉ„Çª„Éº„Ç∏Âèó‰ø°„Éè„É≥„Éâ„É©
    var onPeerMessage: ((String) -> Void)?

    override init() {
        self.peerID = MCPeerID(displayName: UIDevice.current.name)
        self.session = MCSession(peer: self.peerID, securityIdentity: nil, encryptionPreference: .required)
        self.advertiser = MCNearbyServiceAdvertiser(peer: self.peerID, discoveryInfo: nil, serviceType: serviceType)
        self.browser = MCNearbyServiceBrowser(peer: self.peerID, serviceType: serviceType)

        super.init()

        self.session.delegate = self
        self.advertiser.delegate = self
        self.browser.delegate = self

        self.advertiser.startAdvertisingPeer()
        self.browser.startBrowsingForPeers()
        log("MC: advertiser & browser ÈñãÂßã (serviceType: \(serviceType))")
    }

    deinit {
        advertiser.stopAdvertisingPeer()
        browser.stopBrowsingForPeers()
        session.disconnect()
        log("MC: deinit - stopped advertising/browsing and disconnected")
    }

    func log(_ s: String) {
        let entry = LogEntry(message: "[MC] \(s)")
        DispatchQueue.main.async {
            self.logs.append(entry)
            if self.logs.count > 500 { self.logs.removeFirst(self.logs.count - 500) }
        }
        print(entry.formatted)
    }

    func sendToken(_ data: Data) {
        guard session.connectedPeers.count > 0 else {
            log("ÈÄÅ‰ø°ÂÖà„Éî„Ç¢„Åå„ÅÑ„Åæ„Åõ„Çì„ÄÇ")
            return
        }
        do {
            try session.send(data, toPeers: session.connectedPeers, with: .reliable)
            log("„Éà„Éº„ÇØ„É≥ÈÄÅ‰ø°ÊàêÂäü (\(data.count) bytes)")
        } catch {
            log("„Éà„Éº„ÇØ„É≥ÈÄÅ‰ø°Â§±Êïó: \(error)")
        }
    }

    func sendMessage(_ text: String) {
        guard session.connectedPeers.count > 0 else {
            log("ÈÄÅ‰ø°ÂÖà„Éî„Ç¢„Åå„ÅÑ„Åæ„Åõ„Çì„ÄÇ")
            return
        }
        if let data = text.data(using: .utf8) {
            do {
                try session.send(data, toPeers: session.connectedPeers, with: .reliable)
                log("„É°„ÉÉ„Çª„Éº„Ç∏ÈÄÅ‰ø°ÊàêÂäü: \(text)")
            } catch {
                log("„É°„ÉÉ„Çª„Éº„Ç∏ÈÄÅ‰ø°Â§±Êïó: \(error)")
            }
        }
    }
}

// MARK: - MC Delegates
extension MCPeerIDSession: MCSessionDelegate, MCNearbyServiceAdvertiserDelegate, MCNearbyServiceBrowserDelegate {
    func session(_ session: MCSession, peer peerID: MCPeerID, didChange state: MCSessionState) {
        DispatchQueue.main.async {
            self.isConnected = (state == .connected)
        }
        log("\(peerID.displayName) „ÅÆÊé•Á∂öÁä∂ÊÖã: \(state.rawValue)")
        
//        //Ëá™Âãï„ÅßÂÜçÊé•Á∂ö„ÇíË©¶„Åø„Çã
//        if state == .notConnected {
//            // Êé•Á∂ö„ÅåÂàá„Çå„Åü„ÇâÂÜçÊé¢Á¥¢
//            log("Êé•Á∂ö„ÅåÂàá„Çå„Åü„ÅÆ„ÅßÂÜçÊé¢Á¥¢„ÇíÈñãÂßã„Åó„Åæ„Åô")
//            advertiser.stopAdvertisingPeer()
//            browser.stopBrowsingForPeers()
//            advertiser.startAdvertisingPeer()
//            browser.startBrowsingForPeers()
//        }
    }

    func session(_ session: MCSession, didReceive data: Data, fromPeer peerID: MCPeerID) {
        if let text = String(data: data, encoding: .utf8) {
            // UTF-8 „Å®„Åó„Å¶Ëß£Èáà„Åß„Åç„Çå„Å∞„É°„ÉÉ„Çª„Éº„Ç∏
            DispatchQueue.main.async {
                self.onPeerMessage?(text)
            }
            log("üì© „É°„ÉÉ„Çª„Éº„Ç∏Âèó‰ø° from \(peerID.displayName): \(text)")
        } else {
            // „Åù„Çå‰ª•Â§ñ„ÅØ„Éà„Éº„ÇØ„É≥„Éá„Éº„Çø„Å®„Åó„Å¶Êâ±„ÅÜ
            DispatchQueue.main.async {
                self.receivedTokenData = data
            }
            log("„Éà„Éº„ÇØ„É≥„Éá„Éº„ÇøÂèó‰ø°: \(data.count) bytes from \(peerID.displayName)")
        }
    }

    func session(_ session: MCSession, didReceive stream: InputStream, withName streamName: String, fromPeer peerID: MCPeerID) {}
    func session(_ session: MCSession, didStartReceivingResourceWithName resourceName: String, fromPeer peerID: MCPeerID, with progress: Progress) {}
    func session(_ session: MCSession, didFinishReceivingResourceWithName resourceName: String, fromPeer peerID: MCPeerID, at localURL: URL?, withError error: Error?) {}

    func advertiser(_ advertiser: MCNearbyServiceAdvertiser, didReceiveInvitationFromPeer peerID: MCPeerID, withContext context: Data?, invitationHandler: @escaping (Bool, MCSession?) -> Void) {
        log("ÊãõÂæÖ„ÇíÂèó‰ø°: \(peerID.displayName) ‚Äî Ëá™ÂãïÊâøË™ç„Åó„Åæ„Åô„ÄÇ")
        invitationHandler(true, self.session)
    }

    func browser(_ browser: MCNearbyServiceBrowser, foundPeer peerID: MCPeerID, withDiscoveryInfo info: [String : String]?) {
        log("„Éî„Ç¢Áô∫Ë¶ã: \(peerID.displayName) ‚Äî Ëá™Âãï„ÅßÊãõÂæÖ„ÇíÈÄÅ‰ø°„Åó„Åæ„Åô„ÄÇ")
        browser.invitePeer(peerID, to: self.session, withContext: nil, timeout: 10)
    }

    func browser(_ browser: MCNearbyServiceBrowser, lostPeer peerID: MCPeerID) {
        log("„Éî„Ç¢Âñ™Â§±: \(peerID.displayName)")
    }
}
